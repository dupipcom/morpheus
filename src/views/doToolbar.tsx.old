'use client'

import React, { useMemo, useState, useContext, useEffect } from 'react'
import useSWRImmutable from 'swr/immutable'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Button } from '@/components/ui/button'
import Link from 'next/link'
import { useI18n } from '@/lib/contexts/i18n'
import { GlobalContext } from '@/lib/contexts'
import { Plus, Settings as SettingsIcon, Pencil, Package, MoreHorizontal, ChevronDown, Calendar as CalendarIcon, List as ListIcon } from 'lucide-react'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from '@/components/ui/popover'
import { Badge } from '@/components/ui/badge'
import { Card, CardHeader, CardContent, CardTitle } from '@/components/ui/card'
import { Calendar } from '@/components/ui/calendar'
import { Switch } from '@/components/ui/switch'
import { AddTaskForm } from '@/views/forms/AddTaskForm'
import { AddListForm } from '@/views/forms/AddListForm'
import { AddTemplateForm } from '@/views/forms/AddTemplateForm'
import {
  Command,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
} from '@/components/ui/command'

type TaskList = { id: string; name?: string; role?: string }

export const DoToolbar = ({
  locale,
  selectedTaskListId,
  onChangeSelectedTaskListId,
  onAddEphemeral,
}: {
  locale: string
  selectedTaskListId?: string
  onChangeSelectedTaskListId: (id: string) => void
  onAddEphemeral: () => Promise<void> | void
}) => {
  const { t } = useI18n()
  const { taskLists, refreshTaskLists } = useContext(GlobalContext)
  const allTaskLists = taskLists || []
  const selectedList = useMemo(() => allTaskLists.find((l:any) => l.id === selectedTaskListId), [allTaskLists, selectedTaskListId])

  // Ephemeral task form
  const [showAddEphemeral, setShowAddEphemeral] = useState(false)

  // New List form state
  const [showAddList, setShowAddList] = useState(false)
  const [newList, setNewList] = useState({
    name: '',
    templateId: '', // template:{id} or list:{id}
    budget: '',
    dueDate: '',
    cadence: 'one-off',
    role: 'custom',
    collaborators: [] as { id: string, userName: string }[],
  })
  const [newListTasks, setNewListTasks] = useState<any[]>([])
  const [addListTaskOpen, setAddListTaskOpen] = useState(false)
  const [isEditingList, setIsEditingList] = useState(false)

  // New Template form state
  const [showAddTemplate, setShowAddTemplate] = useState(false)
  const [newTemplate, setNewTemplate] = useState({
    name: '',
    createFrom: '', // list:{id}
    visibility: 'PRIVATE',
    tasks: [] as any[],
  })
  const [addTaskOpen, setAddTaskOpen] = useState(false)
  const [addTaskForm, setAddTaskForm] = useState({ name: '', area: 'self', category: 'custom', times: 1 })
  const [dueDateObj, setDueDateObj] = useState<Date | undefined>(undefined)
  const [dateOpen, setDateOpen] = useState(false)
  const [collabQuery, setCollabQuery] = useState('')

  // collaborators search
  const { data: collabResults } = useSWRImmutable(collabQuery ? `/api/v1/profiles?query=${encodeURIComponent(collabQuery)}` : null, async (key) => {
    const res = await fetch(key as string)
    if (!res.ok) return { profiles: [] }
    return res.json()
  })

  // Load user templates
  const { data: templatesResp } = useSWRImmutable('/api/v1/templates', async (key) => {
    const res = await fetch(key as string)
    if (!res.ok) return { templates: [] }
    return res.json()
  })
  const userTemplates = templatesResp?.templates || []

  const closeAll = () => {
    setShowAddEphemeral(false)
    setShowAddList(false)
    setShowAddTemplate(false)
  }

  const handleOpenEditList = async () => {
    if (!selectedList) return
    setIsEditingList(true)
    // derive cadence/role
    let cadence = 'one-off'
    let role = 'custom'
    if (typeof (selectedList as any).role === 'string' && (selectedList as any).role.includes('.')) {
      const [c, r] = (selectedList as any).role.split('.')
      cadence = c || cadence
      role = r || role
    } else if ((selectedList as any).role === 'custom') {
      role = 'custom'
    }

    setNewList({
      name: (selectedList as any).name || '',
      templateId: (selectedList as any).templateId ? `template:${(selectedList as any).templateId}` : '',
      budget: (selectedList as any).budget || '',
      dueDate: (selectedList as any).dueDate || '',
      cadence,
      role,
      collaborators: ((selectedList as any).collaborators || []).map((id: string) => ({ id, userName: id })),
    })
    setNewListTasks(Array.isArray((selectedList as any).tasks) ? (selectedList as any).tasks : [])
    setShowAddList(true)

    // Resolve collaborator usernames
    const ids = (selectedList as any).collaborators || []
    if (Array.isArray(ids) && ids.length) {
      try {
        const res = await fetch(`/api/v1/profiles/by-ids?ids=${encodeURIComponent(ids.join(','))}`)
        if (res.ok) {
          const data = await res.json()
          const map: Record<string, string> = {}
          ;(data.profiles || []).forEach((p: any) => { map[p.userId] = p.userName })
          setNewList(prev => ({
            ...prev,
            collaborators: ids.map((id: string) => ({ id, userName: map[id] || id }))
          }))
        }
      } catch {}
    }
  }

  // moved into AddTaskForm

  const submitList = async () => {
    try {
      const roleJoined = `${newList.cadence}.${newList.role}`
      let tasks: any[] = newListTasks || []
      let templateIdToLink: string | undefined = undefined
      if (newList.templateId?.startsWith('template:')) {
        templateIdToLink = newList.templateId.split(':')[1]
      } else if (newList.templateId?.startsWith('list:')) {
        templateIdToLink = undefined
      }
      await fetch('/api/v1/tasklists', {
        method: 'POST',
        body: JSON.stringify({
          create: !isEditingList,
          role: roleJoined,
          name: newList.name || undefined,
          budget: newList.budget || undefined,
          dueDate: newList.dueDate || undefined,
          templateId: templateIdToLink,
          collaborators: newList.collaborators.map(c => c.id),
          tasks,
        })
      })
      setShowAddList(false)
      setIsEditingList(false)
      setNewList({ name: '', templateId: '', budget: '', dueDate: '', cadence: 'one-off', role: 'custom', collaborators: [] })
      await refreshTaskLists()
    } catch {}
  }

  const submitTemplate = async () => {
    const previewTasks = (() => {
      if (newTemplate.createFrom?.startsWith('list:')) {
        const lstId = newTemplate.createFrom.split(':')[1]
        const lst = allTaskLists.find((l: any) => l.id === lstId)
        return Array.isArray(lst?.tasks) ? lst.tasks : []
      }
      return [] as any[]
    })()
    const tasks = newTemplate.tasks.length > 0 ? newTemplate.tasks : previewTasks
    if (!newTemplate.name.trim()) return
    await fetch('/api/v1/templates', {
      method: 'POST',
      body: JSON.stringify({ name: newTemplate.name.trim(), tasks, visibility: newTemplate.visibility })
    })
    setShowAddTemplate(false)
    setNewTemplate({ name: '', createFrom: '', visibility: 'PRIVATE', tasks: [] })
  }

  // Preview/aggregation logic copied from TaskView
  const newTemplatePreviewTasks = useMemo(() => {
    if (newTemplate.createFrom?.startsWith('list:')) {
      const lstId = newTemplate.createFrom.split(':')[1]
      const lst = allTaskLists.find((l: any) => l.id === lstId)
      return Array.isArray(lst?.tasks) ? lst.tasks : []
    }
    return [] as any[]
  }, [newTemplate.createFrom, allTaskLists])

  const newTemplateAggregatedTasks = useMemo(() => {
    return [...newTemplate.tasks, ...newTemplatePreviewTasks]
  }, [newTemplate.tasks, newTemplatePreviewTasks])

  const newListPreviewTasks = useMemo(() => {
    if (!newList.templateId) return [] as any[]
    if (newList.templateId.startsWith('template:')) {
      const tplId = newList.templateId.split(':')[1]
      const tpl = userTemplates.find((t: any) => t.id === tplId)
      return Array.isArray(tpl?.tasks) ? tpl.tasks : []
    }
    if (newList.templateId.startsWith('list:')) {
      const lstId = newList.templateId.split(':')[1]
      const lst = allTaskLists.find((l: any) => l.id === lstId)
      return Array.isArray(lst?.tasks) ? lst.tasks : []
    }
    return [] as any[]
  }, [newList.templateId, userTemplates, allTaskLists])

  useEffect(() => { setNewListTasks(newListPreviewTasks) }, [newListPreviewTasks])

  console.log("DOTOOLBAR", { selectedTaskListId })
  
  return (
    <div className="space-y-3">
      <div className="flex items-center gap-2">
        <Select value={selectedTaskListId} onValueChange={onChangeSelectedTaskListId}>
          <SelectTrigger className="w-[260px]">
            <SelectValue placeholder={t('tasks.selectList') || 'Select list'} />
          </SelectTrigger>
          <SelectContent>
            {allTaskLists.map((tl:any) => (
              <SelectItem key={tl.id} value={tl.id}>
                {tl.name || tl.role || tl.id}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>

        <div className="ml-auto flex items-center gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                size="sm"
                className="flex items-center text-muted-foreground hover:text-foreground"
              >
                <Plus className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => { closeAll(); setShowAddEphemeral(true) }}>
                {t('common.newTask') || 'New task'}
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => { closeAll(); setIsEditingList(false); setShowAddList(true) }}>
                {t('common.newList') || 'New list'}
              </DropdownMenuItem>
              <DropdownMenuItem onClick={() => { closeAll(); setShowAddTemplate(true) }}>
                {t('common.newTemplate') || 'New template'}
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <Button
            variant="ghost"
            size="sm"
            className="flex items-center text-muted-foreground hover:text-foreground"
            onClick={handleOpenEditList}
            disabled={!selectedList}
          >
            <Pencil className="h-4 w-4" />
          </Button>

          <Button asChild variant="ghost" size="sm" className="flex items-center text-muted-foreground hover:text-foreground">
            <Link href={`/${locale}/app/settings`}>
              <SettingsIcon className="h-4 w-4" />
            </Link>
          </Button>
        </div>
      </div>

      {(selectedList as any)?.budget || (selectedList as any)?.dueDate ? (
        <div className="flex items-center gap-2">
          {(selectedList as any)?.budget && (
            <Badge variant="secondary">Budget: {(selectedList as any).budget}</Badge>
          )}
          {(selectedList as any)?.dueDate && (
            <Badge variant="secondary">Due: {(selectedList as any).dueDate}</Badge>
          )}
        </div>
      ) : null}

      {showAddEphemeral && (
        <AddTaskForm
          selectedTaskListId={selectedTaskListId}
          onCancel={() => setShowAddEphemeral(false)}
          onCreated={refreshTaskLists}
        />
      )}

      {showAddList && (
        <AddListForm
          allTaskLists={allTaskLists}
          userTemplates={userTemplates}
          isEditing={isEditingList}
          initialList={isEditingList ? selectedList : undefined}
          onCancel={() => { setShowAddList(false); setIsEditingList(false) }}
          onCreated={refreshTaskLists}
        />
      )}

      {showAddTemplate && (
        <AddTemplateForm
          allTaskLists={allTaskLists}
          onCancel={() => setShowAddTemplate(false)}
          onCreated={refreshTaskLists}
        />
      )}
    </div>
  )
}


